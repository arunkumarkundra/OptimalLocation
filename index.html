<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimal Location Finder</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #555;
            font-size: 1.1em;
        }

        .main-content {
            display: flex;
            gap: 30px;
        }

        .left-panel, .right-panel {
            background: #fff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
        }

        .left-panel {
            flex: 2;
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section-title {
            font-size: 1.5em;
            color: #4a4a4a;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .destination-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            position: relative;
        }

        .destination-input-group input[type="text"] {
            flex-grow: 1;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .destination-input-group input[type="text"]:focus {
            border-color: #667eea;
            outline: none;
        }

        .destination-input-group input[type="number"] {
            width: 80px;
            padding: 12px;
            margin-left: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .autocomplete-dropdown-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 0.95em;
            color: #333;
        }

        .autocomplete-dropdown-item:hover {
            background-color: #f0f0f0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.05em;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
        }

        .btn-primary {
            background-color: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background-color: #5a6cd9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: #f0f2f5;
            color: #333;
            border: 1px solid #ddd;
        }

        .btn-secondary:hover {
            background-color: #e0e2e5;
            transform: translateY(-2px);
        }

        .btn-add {
            background-color: #28a745;
            color: white;
            flex-grow: 1;
        }

        .btn-add:hover {
            background-color: #218838;
        }

        .btn-remove {
            background-color: #dc3545;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            margin-left: 10px;
            font-size: 0.9em;
        }

        .btn-remove:hover {
            background-color: #c82333;
        }

        #destinationsList {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 10px; /* For scrollbar */
        }

        .destination-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px dashed #eee;
            font-size: 0.95em;
            color: #555;
        }

        .destination-item:last-child {
            border-bottom: none;
        }

        .map-container {
            flex-grow: 1;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
        }

        #map {
            height: 100%;
            min-height: 500px; /* Ensure map has a visible height */
            border-radius: 15px;
        }

        .results-section {
            background: #fff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            margin-top: 20px; /* Space between map and results if stacked */
        }

        #results {
            font-size: 1.1em;
            color: #333;
        }

        #results p {
            margin-bottom: 8px;
        }

        #results strong {
            color: #667eea;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            color: #f0f2f5;
            font-size: 0.9em;
        }

        @media (max-width: 992px) {
            .main-content {
                flex-direction: column;
            }
            .right-panel {
                order: -1; /* Move map to top on smaller screens */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üìç Optimal Location Finder</h1>
            <p>Find the best central point based on multiple weighted destinations.</p>
        </header>

        <div class="main-content">
            <div class="left-panel">
                <h2 class="section-title">Add Destinations</h2>
                <div id="destinationInputs">
                    <div class="destination-input-group">
                        <input type="text" class="location-input" placeholder="Enter destination (e.g., 'Paris Eiffel Tower')" data-lat="" data-lon="">
                        <input type="number" class="weight-input" value="1" min="1" title="Weight">
                        <div class="autocomplete-dropdown"></div>
                        <button class="btn btn-remove" onclick="removeDestination(this)">Remove</button>
                    </div>
                </div>
                <button class="btn btn-add" onclick="addDestinationInput()">+ Add Another Destination</button>
                
                <div class="button-group">
                    <button class="btn btn-primary" onclick="calculateOptimalLocation()">Calculate Optimal Location</button>
                    <button class="btn btn-secondary" onclick="resetForm()">Reset</button>
                </div>
                
                <h2 class="section-title" style="margin-top: 30px;">Destination List</h2>
                <div id="destinationsList">
                    </div>
                
                <h2 class="section-title" style="margin-top: 30px;">Import/Export</h2>
                <div class="button-group">
                    <input type="file" id="importJson" accept=".json" style="display: none;" onchange="importDestinations(event)">
                    <button class="btn btn-secondary" onclick="document.getElementById('importJson').click()">Import JSON</button>
                    <button class="btn btn-secondary" onclick="exportDestinations()">Export JSON</button>
                </div>
                
            </div>

            <div class="right-panel">
                <div class="map-container">
                    <h2 class="section-title" style="margin-bottom: 10px;">Location Map</h2>
                    <div id="map"></div>
                </div>
                
                <div class="results-section">
                    <h2 class="section-title">Optimal Location Results</h2>
                    <div id="results">
                        <p>Enter destinations and click "Calculate Optimal Location" to see results.</p>
                    </div>
                    <button class="btn btn-primary" onclick="downloadReport()" style="margin-top: 20px;">Download Report (PDF)</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
    <script>
        let map;
        let userCurrentLat = 12.9716; // Default to Bangalore, India (your current location)
        let userCurrentLon = 77.5946;

        let destinations = [];
        let optimalLocation = null;
        let optimalMarker = null; // To keep track of the optimal location marker
        let destinationMarkers = L.featureGroup(); // To manage destination markers easily

        // Initialize Map
        function initMap() {
            if (map) {
                map.remove();
            }
            map = L.map('map').setView([userCurrentLat, userCurrentLon], 10); // Center on Bangalore
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Add the feature group to the map
            destinationMarkers.addTo(map);

            // Add a marker for the current user location (optional)
            L.marker([userCurrentLat, userCurrentLon]).addTo(map)
                .bindPopup('Your Current Location')
                .openPopup();
        }

        // Setup Autocomplete
        function setupAutocomplete(inputElement, dropdownElement) {
            let currentRequest = null; // To cancel previous requests

            inputElement.addEventListener('input', async function() {
                const query = this.value;
                if (query.length < 3) {
                    dropdownElement.innerHTML = '';
                    dropdownElement.style.display = 'none';
                    return;
                }

                if (currentRequest) {
                    currentRequest.abort(); // Cancel previous request
                }

                dropdownElement.innerHTML = '<div class="autocomplete-dropdown-item">Searching...</div>';
                dropdownElement.style.display = 'block';

                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`;
                
                try {
                    currentRequest = new XMLHttpRequest();
                    currentRequest.open('GET', url);
                    currentRequest.responseType = 'json';
                    currentRequest.onload = function() {
                        if (currentRequest.status === 200) {
                            const data = currentRequest.response;
                            dropdownElement.innerHTML = '';
                            if (data.length > 0) {
                                data.forEach(item => {
                                    const div = document.createElement('div');
                                    div.classList.add('autocomplete-dropdown-item');
                                    div.textContent = item.display_name;
                                    div.addEventListener('click', () => {
                                        inputElement.value = item.display_name;
                                        inputElement.dataset.lat = item.lat;
                                        inputElement.dataset.lon = item.lon;
                                        dropdownElement.innerHTML = '';
                                        dropdownElement.style.display = 'none';
                                        
                                        // Preview on map
                                        previewDestination(inputElement.closest('.destination-input-group'), item.lat, item.lon, item.display_name);
                                    });
                                    dropdownElement.appendChild(div);
                                });
                            } else {
                                dropdownElement.innerHTML = '<div class="autocomplete-dropdown-item">No results found</div>';
                            }
                        } else {
                            dropdownElement.innerHTML = '<div class="autocomplete-dropdown-item">Error fetching results</div>';
                        }
                    };
                    currentRequest.onerror = function() {
                        dropdownElement.innerHTML = '<div class="autocomplete-dropdown-item">Network error</div>';
                    };
                    currentRequest.send();
                } catch (error) {
                    console.error('Autocomplete fetch error:', error);
                    dropdownElement.innerHTML = '<div class="autocomplete-dropdown-item">Error</div>';
                }
            });

            // Hide dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!inputElement.contains(e.target) && !dropdownElement.contains(e.target)) {
                    dropdownElement.style.display = 'none';
                }
            });
        }

        // Preview destination on map
        function previewDestination(inputGroup, lat, lon, name) {
            const index = Array.from(document.querySelectorAll('.destination-input-group')).indexOf(inputGroup);
            
            // Remove existing marker for this input group if it exists
            const existingMarker = destinationMarkers.getLayers().find(layer => layer.options.id === `dest-marker-${index}`);
            if (existingMarker) {
                destinationMarkers.removeLayer(existingMarker);
            }

            // Add new marker
            const marker = L.marker([lat, lon], { id: `dest-marker-${index}` }).addTo(destinationMarkers)
                .bindPopup(`${name} (ID: ${String.fromCharCode(65 + index)})`);
            
            // Optionally, pan map to new marker
            // map.panTo(new L.LatLng(lat, lon));
        }

        // Add Destination Input
        function addDestinationInput() {
            const container = document.getElementById('destinationInputs');
            const newGroup = document.createElement('div');
            newGroup.classList.add('destination-input-group');
            newGroup.innerHTML = `
                <input type="text" class="location-input" placeholder="Enter destination" data-lat="" data-lon="">
                <input type="number" class="weight-input" value="1" min="1" title="Weight">
                <div class="autocomplete-dropdown"></div>
                <button class="btn btn-remove" onclick="removeDestination(this)">Remove</button>
            `;
            container.appendChild(newGroup);

            const newInput = newGroup.querySelector('.location-input');
            const newDropdown = newGroup.querySelector('.autocomplete-dropdown');
            setupAutocomplete(newInput, newDropdown);

            updateDestinationList();
        }

        // Remove Destination Input
        function removeDestination(button) {
            const inputGroup = button.closest('.destination-input-group');
            const index = Array.from(document.querySelectorAll('.destination-input-group')).indexOf(inputGroup);
            
            // Remove marker from map
            const existingMarker = destinationMarkers.getLayers().find(layer => layer.options.id === `dest-marker-${index}`);
            if (existingMarker) {
                destinationMarkers.removeLayer(existingMarker);
            }

            inputGroup.remove();
            updateDestinationList(); // Update the displayed list
            
            // If destinations are removed, recalculate optimal location (optional, depends on UX preference)
            if (destinations.length > 0) {
                 calculateOptimalLocation();
            } else {
                displayResults("Enter destinations and click \"Calculate Optimal Location\" to see results.");
                if (optimalMarker) {
                    map.removeLayer(optimalMarker);
                    optimalMarker = null;
                }
            }
        }

        // Update Destination List Display
        function updateDestinationList() {
            const listContainer = document.getElementById('destinationsList');
            listContainer.innerHTML = '';
            
            const inputGroups = document.querySelectorAll('.destination-input-group');
            inputGroups.forEach((group, index) => {
                const nameInput = group.querySelector('.location-input');
                const weightInput = group.querySelector('.weight-input');
                
                const itemName = nameInput.value || `Destination ${String.fromCharCode(65 + index)}`;
                const itemWeight = weightInput.value || '1';

                const itemDiv = document.createElement('div');
                itemDiv.classList.add('destination-item');
                itemDiv.innerHTML = `
                    <span>${String.fromCharCode(65 + index)}: ${itemName} (Weight: ${itemWeight})</span>
                    <button class="btn btn-secondary btn-remove" onclick="removeDestination(this)">Remove</button>
                `;
                listContainer.appendChild(itemDiv);
            });
        }

        // Haversine Distance Calculation
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of Earth in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;
            return distance;
        }

        // Calculate Optimal Location
        async function calculateOptimalLocation() {
            destinations = [];
            const inputGroups = document.querySelectorAll('.destination-input-group');

            inputGroups.forEach(group => {
                const lat = parseFloat(group.querySelector('.location-input').dataset.lat);
                const lon = parseFloat(group.querySelector('.location-input').dataset.lon);
                const name = group.querySelector('.location-input').value;
                const weight = parseInt(group.querySelector('.weight-input').value);

                if (!isNaN(lat) && !isNaN(lon) && weight > 0) {
                    destinations.push({ lat, lon, name, weight });
                }
            });

            if (destinations.length === 0) {
                alert("Please add at least one valid destination with coordinates.");
                displayResults("Enter destinations and click \"Calculate Optimal Location\" to see results.");
                if (optimalMarker) {
                    map.removeLayer(optimalMarker);
                    optimalMarker = null;
                }
                return;
            }

            displayResults("Calculating optimal location...");

            // Determine search bounds based on destinations
            let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
            destinations.forEach(d => {
                minLat = Math.min(minLat, d.lat);
                maxLat = Math.max(maxLat, d.lat);
                minLon = Math.min(minLon, d.lon);
                maxLon = Math.max(maxLon, d.lon);
            });

            // Expand bounds slightly to ensure optimal point isn't exactly on edge
            const latBuffer = (maxLat - minLat) * 0.1 || 0.01;
            const lonBuffer = (maxLon - minLon) * 0.1 || 0.01;

            minLat -= latBuffer;
            maxLat += latBuffer;
            minLon -= lonBuffer;
            maxLon += lonBuffer;

            // Initial grid resolution (e.g., 0.1 degrees)
            let bestLat = (minLat + maxLat) / 2;
            let bestLon = (minLon + maxLon) / 2;
            let minAvgWeightedDistance = Infinity;

            // Iterative refinement
            const numIterations = 5; // Number of times to refine the search
            const initialStep = Math.max((maxLat - minLat) / 10, (maxLon - minLon) / 10, 0.01); // Initial step size

            for (let iter = 0; iter < numIterations; iter++) {
                const currentStep = initialStep / Math.pow(2, iter); // Halve step size each iteration
                const searchAreaLatMin = bestLat - currentStep * 5;
                const searchAreaLatMax = bestLat + currentStep * 5;
                const searchAreaLonMin = bestLon - currentStep * 5;
                const searchAreaLonMax = bestLon + currentStep * 5;

                for (let lat = searchAreaLatMin; lat <= searchAreaLatMax; lat += currentStep) {
                    for (let lon = searchAreaLonMin; lon <= searchAreaLonMax; lon += currentStep) {
                        let totalWeightedDistance = 0;
                        let totalWeight = 0;

                        destinations.forEach(dest => {
                            const dist = haversineDistance(lat, lon, dest.lat, dest.lon);
                            totalWeightedDistance += dist * dest.weight;
                            totalWeight += dest.weight;
                        });

                        const avgWeightedDistance = totalWeightedDistance / totalWeight;

                        if (avgWeightedDistance < minAvgWeightedDistance) {
                            minAvgWeightedDistance = avgWeightedDistance;
                            bestLat = lat;
                            bestLon = lon;
                        }
                    }
                }
            }
            
            optimalLocation = {
                lat: bestLat,
                lon: bestLon,
                avgWeightedDistance: minAvgWeightedDistance
            };

            displayResults(`
                <p><strong>Optimal Location Found!</strong></p>
                <p>Latitude: <strong>${optimalLocation.lat.toFixed(6)}</strong></p>
                <p>Longitude: <strong>${optimalLocation.lon.toFixed(6)}</strong></p>
                <p>Average Weighted Distance to Destinations: <strong>${optimalLocation.avgWeightedDistance.toFixed(2)} km</strong></p>
                <p style="font-size: 0.9em; color: #777;">(This is the point that minimizes the sum of distances to all destinations, weighted by their importance.)</p>
            `);

            // Clear previous optimal marker
            if (optimalMarker) {
                map.removeLayer(optimalMarker);
            }

            // Add optimal location marker
            optimalMarker = L.marker([optimalLocation.lat, optimalLocation.lon], {
                icon: L.divIcon({
                    className: 'optimal-location-icon',
                    html: '<div style="background-color:#27ae60; color:white; border-radius:50%; width:30px; height:30px; display:flex; justify-content:center; align-items:center; font-weight:bold; font-size:1.2em; border:3px solid #fff;">‚òÖ</div>',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            }).addTo(map)
                .bindPopup(`Optimal Location: ${optimalLocation.lat.toFixed(6)}, ${optimalLocation.lon.toFixed(6)}`)
                .openPopup();

            // Fit map to include all destinations and optimal location
            const allPoints = destinations.map(d => [d.lat, d.lon]);
            allPoints.push([optimalLocation.lat, optimalLocation.lon]);
            const bounds = L.latLngBounds(allPoints);
            map.fitBounds(bounds, { padding: [50, 50] });
        }

        function displayResults(htmlContent) {
            document.getElementById('results').innerHTML = htmlContent;
        }

        function resetForm() {
            document.getElementById('destinationInputs').innerHTML = `
                <div class="destination-input-group">
                    <input type="text" class="location-input" placeholder="Enter destination (e.g., 'Paris Eiffel Tower')" data-lat="" data-lon="">
                    <input type="number" class="weight-input" value="1" min="1" title="Weight">
                    <div class="autocomplete-dropdown"></div>
                    <button class="btn btn-remove" onclick="removeDestination(this)">Remove</button>
                </div>
            `;
            const initialInput = document.querySelector('.location-input');
            const initialDropdown = document.querySelector('.autocomplete-dropdown');
            setupAutocomplete(initialInput, initialDropdown);
            updateDestinationList();
            destinations = [];
            optimalLocation = null;
            displayResults("Enter destinations and click \"Calculate Optimal Location\" to see results.");
            // Clear all markers from the map
            destinationMarkers.clearLayers();
            if (optimalMarker) {
                map.removeLayer(optimalMarker);
                optimalMarker = null;
            }
            // Re-initialize map to default view
            initMap();
        }

        function checkPageBreak(doc, yPos, requiredSpace) {
            // A4 page height is approx 297mm. Top/bottom margins typically 10mm each.
            // Content area approx 277mm.
            // jsPDF coordinates are in 'pt' by default, 1mm = 2.83465 pt.
            // Assuming default units (mm or pt), let's use a simplified check
            // assuming an effective page height.
            const pageHeight = doc.internal.pageSize.height;
            const bottomMargin = 20; // Example bottom margin

            if (yPos + requiredSpace > pageHeight - bottomMargin) {
                doc.addPage();
                return 20; // New Y position at top of new page
            }
            return yPos;
        }

        async function downloadReport() {
            if (!optimalLocation || destinations.length === 0) {
                alert('No results to generate report');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // Title
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.text('Optimal Location Analysis Report', 20, 25);

            // Timestamp and additional info
            const timestamp = new Date().toLocaleString();
            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`Generated on: ${timestamp}`, 20, 35);
            doc.text('Generated by Optimal Location Finder', 20, 42);
            doc.text(`Visit: ${window.location.origin}${window.location.pathname}`, 20, 49);

            let yPos = 60;

            // Optimal Location Details (Highlighted)
            doc.setFillColor(39, 174, 96); // Green background
            doc.rect(15, yPos - 5, 180, 25, 'F');
            doc.setTextColor(255, 255, 255); // White text
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('OPTIMAL LOCATION', 20, yPos + 5);

            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            doc.text(`Coordinates: ${optimalLocation.lat.toFixed(6)}, ${optimalLocation.lon.toFixed(6)}`, 20, yPos + 12);
            doc.text(`Average Weighted Distance: ${optimalLocation.avgWeightedDistance.toFixed(2)} km`, 20, yPos + 18);

            yPos += 35;
            doc.setTextColor(0, 0, 0); // Reset to black

            // Map Image - AWAIT the result from captureMapAsImage
            try {
                const mapImage = await captureMapAsImage(); // <--- CHANGE IS HERE: AWAIT THE PROMISE
                if (mapImage) { // Only add if image was successfully generated
                    // Parameters: imageData, format, x, y, width, height
                    // Adjust width/height as needed for your PDF layout, maintaining aspect ratio
                    // The aspect ratio from leafletImage options (800x533) is ~1.5.
                    // If you use 170mm width for PDF, height should be 170 / 1.5 = ~113.33mm
                    doc.addImage(mapImage, 'PNG', 20, yPos, 170, 113.33);
                    yPos += 125; // Increase yPos to account for image height plus some margin
                } else {
                    doc.setFontSize(10);
                    doc.text('Map visualization not available', 20, yPos);
                    yPos += 15;
                }
            } catch (error) {
                console.error('Could not capture map:', error);
                doc.setFontSize(10);
                doc.text('Map visualization not available due to an error.', 20, yPos);
                yPos += 15;
            }

            // Check if we need a new page for the table
            yPos = checkPageBreak(doc, yPos, 30);

            // Destinations Table
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('Destinations Summary', 20, yPos);
            yPos += 10;

            // Table headers
            doc.setFontSize(10);
            doc.setFont(undefined, 'bold');
            doc.text('ID', 20, yPos);
            doc.text('Name', 35, yPos);
            doc.text('Weight', 100, yPos);
            doc.text('Distance from Optimal', 130, yPos);
            doc.text('Weighted Impact', 175, yPos);

            // Table header line
            doc.line(15, yPos + 2, 195, yPos + 2);
            yPos += 8;

            // Table rows
            doc.setFont(undefined, 'normal');
            destinations.forEach((dest, index) => {
                yPos = checkPageBreak(doc, yPos, 8);
                const distance = haversineDistance(optimalLocation.lat, optimalLocation.lon, dest.lat, dest.lon);
                const letter = String.fromCharCode(65 + index);

                doc.text(letter, 20, yPos);
                doc.text(dest.name.length > 15 ? dest.name.substring(0, 15) + '...' : dest.name, 35, yPos);
                doc.text(dest.weight.toString(), 100, yPos);
                doc.text(`${distance.toFixed(2)} km`, 130, yPos);
                doc.text(`${(distance * dest.weight).toFixed(2)}`, 175, yPos);
                yPos += 6;
            });


            // Analysis Summary
            yPos += 10;
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text('Analysis Summary', 20, yPos);
            yPos += 8;

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`Total destinations analyzed: ${destinations.length}`, 20, yPos);
            yPos += 5;
            doc.text(`Optimization method: Iterative grid search with adaptive refinement`, 20, yPos);
            yPos += 5;
            doc.text(`Search resolution: Up to 100-meter precision`, 20, yPos);


            // Save PDF
            const reportTimestamp = new Date().toISOString().replace(/[-:T]/g, '').slice(0, 14);
            doc.save(`optimal_location_report_${reportTimestamp}.pdf`);
        }

        function captureMapAsImage() {
            return new Promise((resolve) => {
                leafletImage(map, function(err, canvas) {
                    if (err) {
                        console.error("Error capturing map image:", err);
                        resolve(null);
                        return;
                    }
                    resolve(canvas.toDataURL('image/png'));
                }, {
                    width: 800,
                    height: 533, // maintain ~1.5 aspect ratio
                });
            });
        }
        
        // Export results to CSV
        function exportDestinations() {
            if (destinations.length === 0) {
                alert("No destinations to export.");
                return;
            }

            const data = destinations.map(d => ({
                name: d.name,
                latitude: d.lat,
                longitude: d.lon,
                weight: d.weight
            }));

            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'destinations.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import Destinations from JSON
        function importDestinations(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Clear existing destinations and markers
                    resetForm(); // Clears map, inputs, and results

                    const container = document.getElementById('destinationInputs');
                    container.innerHTML = ''; // Clear default input group

                    let validDestinations = [];

                    importedData.forEach((dest, index) => {
                        // Create a new input group for each imported destination
                        const newGroup = document.createElement('div');
                        newGroup.classList.add('destination-input-group');
                        newGroup.innerHTML = `
                            <input type="text" class="location-input" placeholder="Enter destination" data-lat="" data-lon="">
                            <input type="number" class="weight-input" value="1" min="1" title="Weight">
                            <div class="autocomplete-dropdown"></div>
                            <button class="btn btn-remove" onclick="removeDestination(this)">Remove</button>
                        `;
                        container.appendChild(newGroup);

                        const nameInput = newGroup.querySelector('.location-input');
                        const weightInput = newGroup.querySelector('.weight-input');
                        const dropdown = newGroup.querySelector('.autocomplete-dropdown');

                        // Set values from imported data
                        nameInput.value = dest.name || '';
                        nameInput.dataset.lat = dest.latitude;
                        nameInput.dataset.lon = dest.longitude;
                        weightInput.value = dest.weight || 1;
                        
                        // Setup autocomplete for the new input
                        setupAutocomplete(nameInput, dropdown);

                        // If valid coordinates, add to a temporary list for map plotting
                        if (!isNaN(parseFloat(dest.latitude)) && !isNaN(parseFloat(dest.longitude))) {
                            validDestinations.push({ 
                                lat: parseFloat(dest.latitude), 
                                lon: parseFloat(dest.longitude),
                                name: dest.name,
                                weight: dest.weight
                            });
                        }
                    });

                    // After all inputs are added, update the destination list display
                    updateDestinationList();

                    // Now plot all imported valid destinations on the map
                    validDestinations.forEach((dest, index) => {
                        const destinationItem = document.querySelectorAll('.destination-input-group')[index];
                        const displayName = dest.name || `Destination ${String.fromCharCode(65 + index)}`;
                        previewDestination(destinationItem, dest.lat, dest.lon, displayName);
                    });

                    // Recalculate optimal location for imported destinations
                    if (validDestinations.length > 0) {
                        calculateOptimalLocation();
                    } else {
                        alert("No valid destinations found in the imported file. Please check the format.");
                    }


                } catch (error) {
                    console.error('Error importing JSON file:', error);
                    alert("Could not parse the imported file. Please ensure it is a valid JSON format.");
                    // No changes made to UI if parsing fails
                }
            };

            reader.readAsText(file);
        }



        
        // Initialize the app

window.onload = function() {
    initMap();
    
    // Setup autocomplete for initial destination
    const initialInput = document.querySelector('.location-input');
    const initialDropdown = document.querySelector('.autocomplete-dropdown');
    setupAutocomplete(initialInput, initialDropdown);
    
    // Setup initial remove button
    const initialRemoveButton = document.querySelector('.remove-destination');
    initialRemoveButton.addEventListener('click', function() {
        removeDestination(this);
    });
};
        
    </script>
</body>
</html>
