<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimal Location Finder</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.1rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            align-items: start;
        }

        .input-section {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(102, 126, 234, 0.1);
        }

        .input-section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .destination-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        

        .destination-item:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.1);
        }

        .destination-inputs {
            display: grid;
            grid-template-columns: 2fr 2fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .destination-inputs input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .destination-inputs input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

.autocomplete-container {
    position: relative;
}

.autocomplete-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-top: none;
    border-radius: 0 0 8px 8px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.autocomplete-option {
    padding: 12px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    transition: background 0.2s;
}

.autocomplete-option:hover {
    background: #f8f9fa;
}

.autocomplete-option:last-child {
    border-bottom: none;
}

.destination-label {
    margin-top: 10px;
    font-weight: 600;
    color: #667eea;
}

.dest-letter {
    display: inline-block;
    width: 25px;
    height: 25px;
    background: #667eea;
    color: white;
    text-align: center;
    line-height: 25px;
    border-radius: 50%;
    font-size: 0.9rem;
}
        
        .weight-input {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #e74c3c;
            color: white;
            font-size: 0.8rem;
            padding: 8px 16px;
        }

        .btn-secondary:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
            color: white;
            width: 100%;
            margin: 20px 0;
            font-size: 1rem;
            padding: 15px;
        }

        .btn-success:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(39, 174, 96, 0.3);
        }

        #map {
            height: 600px;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            border: 3px solid rgba(102, 126, 234, 0.1);
        }

        .results-section {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
        }

        .results-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .result-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.9rem;
            color: #2c3e50;
            font-weight: 600;
        }

        .control-group input, .control-group select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .destination-inputs {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè† Optimal Location Finder</h1>
            <p>Find the perfect location based on your frequent destinations. Enter locations you visit regularly with their importance weights.</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <h2>üìç Destinations</h2>
<div style="display: flex; justify-content: flex-end; margin-top: -10px;">
    <input type="file" id="importFile" accept=".json" style="display:none;" onchange="importResults(event)">
    <button
        onclick="document.getElementById('importFile').click()"
        style="padding: 4px 10px; font-size: 12px; background-color: #ddd; color: #333; border: 1px solid #bbb; border-radius: 4px; cursor: pointer;">
        üìÇ Import Data
    </button>
</div>


                
                <div id="destinationsContainer">
                    <div class="destination-item">
<div class="destination-inputs">
    <div class="autocomplete-container">
        <input type="text" placeholder="Address, place name, or coordinates" class="location-input">
        <div class="autocomplete-dropdown" style="display: none;"></div>
    </div>
    <input type="text" placeholder="Name (optional)" class="name-input">
    <input type="number" min="0.1" step="0.1" value="1.0" class="weight-input" placeholder="Weight">
</div>
<div class="destination-label">Destination: <span class="dest-letter">A</span></div>
                        <button class="btn btn-secondary remove-destination">Remove</button>
                    </div>
                </div>

                <button class="btn btn-primary" onclick="addDestination()">+ Add Destination</button>
                                
                <button class="btn btn-success" onclick="findOptimalLocation()">üéØ Find Optimal Location</button>

                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    Calculating optimal location...
                </div>

                <div class="results-section" id="results" style="display: none;">
                    <h3>üìä Results</h3>
                    <div id="resultsContent"></div>
                    <button class="btn btn-primary" onclick="exportResults()">üìÑ Export Results</button>
                </div>
            </div>

            <div id="map"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        let map;
let userCurrentLat = 12.9716; // Default to Bangalore, India (your current location)
let userCurrentLon = 77.5946; // Default to Bangalore, India (your current location)
        
        let destinations = [];
        let gridPoints = [];
        let optimalLocation = null;
        let layerGroups = {
            destinations: L.layerGroup(),
            grid: L.layerGroup(),
            optimal: L.layerGroup()
        };
        let destinationCounter = 0;
        let geocodeTimeouts = {};
        
        // Initialize map

function initMap() {
    map = L.map('map').setView([userCurrentLat, userCurrentLon], 10); // Use default/user location
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);

    // Add layer groups to map
    Object.values(layerGroups).forEach(layer => layer.addTo(map));

    // Attempt to get user's current location
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                userCurrentLat = position.coords.latitude;
                userCurrentLon = position.coords.longitude;
                map.setView([userCurrentLat, userCurrentLon], 13); // Set view to user's location with a closer zoom
                L.marker([userCurrentLat, userCurrentLon], {
                    icon: L.divIcon({
                        html: `<div style="background: #3498db; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">üè†</div>`,
                        iconSize: [30, 30],
                        className: 'current-location-marker'
                    })
                }).addTo(map).bindPopup('Your Current Location');
            },
            (error) => {
                console.warn('Geolocation error:', error);
//                alert('Could not retrieve your location. Map will default to Bangalore for initial view and search bias.');
            },
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
        );
    } else {
//        alert('Geolocation is not supported by your browser. Map will default to Bangalore for initial view and search bias.');
    }
}

function computeOptimalLocation_Weiszfeld(destinations, maxIterations = 100000, tolerance = 1e-7) {
    if (destinations.length === 0) {
        return null;
    }
    if (destinations.length === 1) {
        return { lat: destinations[0].lat, lon: destinations[0].lon };
    }

    const totalWeight = destinations.reduce((sum, dest) => sum + dest.weight, 0);
    let x = destinations.reduce((sum, dest) => sum + dest.lon * dest.weight, 0) / totalWeight;
    let y = destinations.reduce((sum, dest) => sum + dest.lat * dest.weight, 0) / totalWeight;

// returning weighted average itself without loop calculation 
        return { lon: x, lat: y };
    
    for (let iter = 0; iter < maxIterations; iter++) {
        let numLat = 0;
        let numLon = 0;
        let denom = 0;
        let closeToPoint = false;

        for (let i = 0; i < destinations.length; i++) {
            const dest = destinations[i];
            const dist = haversineDistance(y, x, dest.lat, dest.lon);

            if (dist < tolerance) {
                // Perturb slightly to avoid divide-by-zero and premature stopping
                const perturbationFactor = tolerance * 10;
                x += (Math.random() - 0.5) * perturbationFactor;
                y += (Math.random() - 0.5) * perturbationFactor;
                closeToPoint = true;
                break;
            }

            const weightOverDist = dest.weight / dist;
            numLon += dest.lon * weightOverDist;
            numLat += dest.lat * weightOverDist;
            denom += weightOverDist;
        }

        if (closeToPoint) {
            continue; // Skip update, try again from perturbed position
        }

        const newX = numLon / denom;
        const newY = numLat / denom;

        const delta = haversineDistance(y, x, newY, newX);
        x = newX;
        y = newY;

        if (delta < tolerance) {
            break; // Converged
        }
    }

    return { lon: x, lat: y };
}


        
        
        // Haversine distance calculation
function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in km
    const toRad = angle => angle * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}



        // Geocoding using Nominatim

async function geocode(address, biasLat = null, biasLon = null) {
    try {
        let url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`;

        // Prioritize passed bias, then user's current location, then default (Bangalore)
        if (biasLat && biasLon) {
            url += `&lat=${biasLat}&lon=${biasLon}&radius=50000`; // 50km radius
        } else if (userCurrentLat && userCurrentLon) { // Use user's current location if available (even if it's the default Bangalore)
            url += `&lat=${userCurrentLat}&lon=${userCurrentLon}&radius=100000`; // 100km radius around user/default
        } else {
            url += `&lat=12.9716&lon=77.5946&radius=100000`; // Fallback to Bangalore if all else fails (shouldn't be hit with global defaults)
        }

        const response = await fetch(url);
        const data = await response.json();
        if (data && data.length > 0) {
            return {
                lat: parseFloat(data[0].lat),
                lon: parseFloat(data[0].lon),
                display_name: data[0].display_name
            };
        }
        throw new Error('Location not found');
    } catch (error) {
        console.error('Geocoding error:', error);
        throw error;
    }
}

        // Add destination input

 function addDestination() {
    const container = document.getElementById('destinationsContainer');
    const destinationItem = document.createElement('div');
    const letter = getDestinationLetter(container.children.length);
    
    destinationItem.className = 'destination-item';
    destinationItem.innerHTML = `
        <div class="destination-inputs">
            <div class="autocomplete-container">
                <input type="text" placeholder="Address, place name, or coordinates" class="location-input">
                <div class="autocomplete-dropdown" style="display: none;"></div>
            </div>
            <input type="text" placeholder="Name (optional)" class="name-input">
            <input type="number" min="0.1" step="0.1" value="1.0" class="weight-input" placeholder="Weight">
        </div>
        <div class="destination-label">Destination: <span class="dest-letter">${letter}</span></div>
        <button class="btn btn-secondary remove-destination">Remove</button>
    `;
    
    container.appendChild(destinationItem);
    updateAllDestinationMarkers();
    destinationItem.scrollIntoView({ behavior: 'smooth', block: 'center' });


    // Setup autocomplete for the new input
    const input = destinationItem.querySelector('.location-input');
    const dropdown = destinationItem.querySelector('.autocomplete-dropdown');
    setupAutocomplete(input, dropdown);
    
    // Setup remove button event
    const removeButton = destinationItem.querySelector('.remove-destination');
    removeButton.addEventListener('click', function() {
        removeDestination(this);
    });
}
// Get letter for destination (A, B, C...)
function getDestinationLetter(index) {
    return String.fromCharCode(65 + index); // A=65, B=66, etc.
}

// Parse coordinates from string

function parseCoordinates(input) {
    // Match strictly: latitude, longitude (comma separated)
    const coordRegex = /^\s*([-+]?\d{1,2}(?:\.\d+)?),\s*([-+]?\d{1,3}(?:\.\d+)?)\s*$/;
    const match = input.trim().match(coordRegex);
    
    if (match) {
        const lat = parseFloat(match[1]);
        const lon = parseFloat(match[2]);

        if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
            return { lat, lon };
        }
    }
    return null;
}



// Setup autocomplete for location input
function setupAutocomplete(input, dropdown) {
    let currentRequest = null;

    input.addEventListener('input', function() {
        const query = this.value.trim();
        dropdown.style.display = 'none';

        if (query.length < 3) return;

        // Check if it's coordinates
        const coords = parseCoordinates(query);
        if (coords) {
            showCoordinateOption(dropdown, coords, query);
            return;
        }

        // Cancel previous request
        if (currentRequest) {
            clearTimeout(currentRequest);
        }

        // Debounce API calls
        currentRequest = setTimeout(async () => {
            try {
                let searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=8&addressdetails=1`;

                let biasLat = userCurrentLat; // Start with user's current location as primary bias
                let biasLon = userCurrentLon;

                // Get the index of the current destination item
                const destinationItem = input.closest('.destination-item');
                const currentIndex = Array.from(destinationItem.parentElement.children).indexOf(destinationItem);

                // For subsequent destinations (not the first one), use the previous destination as bias
                if (currentIndex > 0) {
                    const prevItem = destinationItem.previousElementSibling;
                    const prevInput = prevItem ? prevItem.querySelector('.location-input') : null;
                    if (prevInput && prevInput.getAttribute('data-lat') && prevInput.getAttribute('data-lon')) {
                        biasLat = parseFloat(prevInput.getAttribute('data-lat'));
                        biasLon = parseFloat(prevInput.getAttribute('data-lon'));
                    }
                }

                // Apply bias if coordinates are valid
                if (biasLat && biasLon) {
                    searchUrl += `&lat=${biasLat}&lon=${biasLon}&radius=100000`; // 100km radius around bias point
                } else {
                    // Fallback to Bangalore if no user location or previous destination is available/valid
                    searchUrl += `&lat=12.9716&lon=77.5946&radius=100000`;
                }

                const response = await fetch(searchUrl);
                const results = await response.json();
                showAutocompleteOptions(dropdown, results, input);
            } catch (error) {
                console.error('Autocomplete error:', error);
            }
        }, 300);
    });

    // Hide dropdown when clicking outside
    document.addEventListener('click', function(e) {
        if (!input.contains(e.target) && !dropdown.contains(e.target)) {
            dropdown.style.display = 'none';
        }
    });
}
        
// Show coordinate option in dropdown
function showCoordinateOption(dropdown, coords, originalQuery) {
    dropdown.innerHTML = `
        <div class="autocomplete-option" data-lat="${coords.lat}" data-lon="${coords.lon}" data-name="${originalQuery}">
            üìç Coordinates: ${coords.lat}, ${coords.lon}
        </div>
    `;
    dropdown.style.display = 'block';
    
    // Add click event listener
dropdown.querySelector('.autocomplete-option').addEventListener('click', function() {
    const destinationItem = this.closest('.destination-item');
    const input = destinationItem.querySelector('.location-input');
    input.value = originalQuery;
    input.setAttribute('data-lat', coords.lat);
    input.setAttribute('data-lon', coords.lon);
    input.setAttribute('data-display-name', originalQuery);
    dropdown.style.display = 'none';
    previewDestination(destinationItem, coords.lat, coords.lon, originalQuery);
});
}

        
// Show autocomplete options
function showAutocompleteOptions(dropdown, results, input) {
    if (results.length === 0) {
        dropdown.style.display = 'none';
        return;
    }
    
    dropdown.innerHTML = results.map(result => `
        <div class="autocomplete-option" data-lat="${result.lat}" data-lon="${result.lon}" data-name="${result.display_name}">
            üìç ${result.display_name}
        </div>
    `).join('');
    
    dropdown.style.display = 'block';
    
    // Add click event listeners
    dropdown.querySelectorAll('.autocomplete-option').forEach(option => {
        option.addEventListener('click', function() {
            const lat = this.getAttribute('data-lat');
            const lon = this.getAttribute('data-lon');
            const name = this.getAttribute('data-name');
            selectLocation(lat, lon, name, this);
        });
    });
}

        
// Select coordinate from dropdown
function selectCoordinate(lat, lon, query, element) {
    const input = element.closest('.destination-item').querySelector('.location-input');
    input.value = query;
    element.closest('.autocomplete-dropdown').style.display = 'none';
    previewDestination(element.closest('.destination-item'), parseFloat(lat), parseFloat(lon), query);
}

// Select location from dropdown

function selectLocation(lat, lon, displayName, element) {
    const destinationItem = element.closest('.destination-item');
    const input = destinationItem.querySelector('.location-input');
    const dropdown = destinationItem.querySelector('.autocomplete-dropdown');
    
    input.value = displayName.length > 50 ? displayName.substring(0, 50) + '...' : displayName;
    dropdown.style.display = 'none';
    
    // Store coordinates as data attributes
    input.setAttribute('data-lat', lat);
    input.setAttribute('data-lon', lon);
    input.setAttribute('data-display-name', displayName);
    
    previewDestination(destinationItem, parseFloat(lat), parseFloat(lon), displayName);
}
        

        
        
// Preview destination on map

function previewDestination(destinationItem, lat, lon, displayName) {
    const destIndex = Array.from(destinationItem.parentElement.children).indexOf(destinationItem);
    const letter = getDestinationLetter(destIndex);

    // ‚úÖ Force-save lat/lon/display_name into the input's dataset
    const input = destinationItem.querySelector('.location-input');
    input.setAttribute('data-lat', lat);
    input.setAttribute('data-lon', lon);
    input.setAttribute('data-display-name', displayName);

    // Remove existing preview for this destination
    layerGroups.destinations.eachLayer(layer => {
        if (layer.options && layer.options.destIndex === destIndex) {
            layerGroups.destinations.removeLayer(layer);
        }
    });

    // Add new preview marker
    const marker = L.marker([lat, lon], {
        icon: L.divIcon({
            html: `<div style="background: #e74c3c; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${letter}</div>`,
            iconSize: [30, 30],
            className: 'preview-marker'
        }),
        destIndex: destIndex
    }).bindPopup(`<strong>Preview: ${letter}</strong><br><small>${displayName}</small>`);

    layerGroups.destinations.addLayer(marker);
    map.setView([lat, lon], Math.max(map.getZoom(), 12));
}

        
        // Remove destination input

function updateAllDestinationMarkers() {
    layerGroups.destinations.clearLayers(); // Clear all destination markers

    const container = document.getElementById('destinationsContainer');
    const items = container.querySelectorAll('.destination-item');

    items.forEach((item, index) => {
        const locationInput = item.querySelector('.location-input');
        const lat = parseFloat(locationInput.getAttribute('data-lat'));
        const lon = parseFloat(locationInput.getAttribute('data-lon'));
        const displayName = locationInput.getAttribute('data-display-name');
        
        // Update label in DOM
        item.querySelector('.dest-letter').textContent = getDestinationLetter(index);

        if (lat && lon && displayName) {
            previewDestination(item, lat, lon, displayName);
        }
    });
}


        
function removeDestination(button) {
    const container = document.getElementById('destinationsContainer');
    if (container.children.length > 1) {
        button.parentElement.remove();
        updateAllDestinationMarkers();  // Re-render all markers
    }
}


        

        // Get color based on weighted distance (green = better, red = worse)
        function getColorForDistance(distance, minDist, maxDist) {
            const normalized = (distance - minDist) / (maxDist - minDist);
            // const hue = (1 - normalized) * 120; // 120 = green, 0 = red
            // return `hsl(${hue}, 70%, 50%)`;

            const hue = (1 - normalized) * 120;
            return `hsl(${hue}, 90%, 45%)`; // Brighter, punchier color
        }

        // Main function to find optimal location
        async function findOptimalLocation() {
            document.getElementById('loading').classList.add('show');
            document.getElementById('results').style.display = 'none';
            
            try {
                // Clear previous results
                Object.values(layerGroups).forEach(layer => layer.clearLayers());
                
                // Collect destinations
                destinations = [];
                const destinationItems = document.querySelectorAll('.destination-item');


for (let item of destinationItems) {
    const locationInput = item.querySelector('.location-input');
    const location = locationInput.value.trim();
    const name = item.querySelector('.name-input').value.trim() || location;
    const weight = parseFloat(item.querySelector('.weight-input').value) || 1.0;
    
    if (location) {
        // Check if coordinates are already stored
        const storedLat = locationInput.getAttribute('data-lat');
        const storedLon = locationInput.getAttribute('data-lon');
        const storedDisplayName = locationInput.getAttribute('data-display-name');
        
        if (storedLat && storedLon) {
            // Use stored coordinates
            destinations.push({
                name: name,
                location: location,
                lat: parseFloat(storedLat),
                lon: parseFloat(storedLon),
                weight: weight,
                display_name: storedDisplayName || location
            });
        } else {
            // Fallback to geocoding if no stored coordinates
            try {
                const coords = await geocode(location);
                destinations.push({
                    name: name,
                    location: location,
                    lat: coords.lat,
                    lon: coords.lon,
                    weight: weight,
                    display_name: coords.display_name
                });
            } catch (error) {
                alert(`Could not find location: ${location}`);
                continue;
            }
        }
    }
}
                

                if (destinations.length < 1) {
                    alert('Please add at least one valid destination');
                    return;
                }

// Compute optimal location using Weiszfeld‚Äôs algorithm
const result = computeOptimalLocation_Weiszfeld(destinations);

// Add back average weighted distance
let totalWeightedDistance = 0, totalWeight = 0;
for (const dest of destinations) {
    const dist = haversineDistance(result.lat, result.lon, dest.lat, dest.lon);
    totalWeightedDistance += dist * dest.weight;
    totalWeight += dest.weight;
}
result.avgWeightedDistance = totalWeightedDistance / totalWeight;

optimalLocation = result;


                
                // Visualize results
                await visualizeResults();
                displayResults();

            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while calculating the optimal location');
            } finally {
                document.getElementById('loading').classList.remove('show');
            }
        }

        // Visualize results on map
        async function visualizeResults() {
            // Add destinations
            destinations.forEach((dest, index) => {
    const letter = getDestinationLetter(index);
    const marker = L.marker([dest.lat, dest.lon], {
        icon: L.divIcon({
            html: `<div style="background: #e74c3c; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${letter}</div>`,
            iconSize: [30, 30],
            className: 'custom-marker'
        })
    }).bindPopup(`
        <strong>${letter}. ${dest.name}</strong><br>
        Weight: ${dest.weight}<br>
        <small>${dest.display_name}</small>
    `);
                layerGroups.destinations.addLayer(marker);
            });


            // Add optimal location
            const optimalMarker = L.marker([optimalLocation.lat, optimalLocation.lon], {
                icon: L.divIcon({
                    html: `<div style="background: #27ae60; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 4px solid white; box-shadow: 0 3px 8px rgba(0,0,0,0.4); font-size: 18px;">‚òÖ</div>`,
                    iconSize: [40, 40],
                    className: 'optimal-marker'
                })
            }).bindPopup(`
                <strong>üè† Optimal Location</strong><br>
                Avg Weighted Distance: ${optimalLocation.avgWeightedDistance.toFixed(2)} km<br>
                Coordinates: ${optimalLocation.lat.toFixed(6)}, ${optimalLocation.lon.toFixed(6)}
            `);
            layerGroups.optimal.addLayer(optimalMarker);

            // Fit map to show all points
            const allPoints = [...destinations.map(d => [d.lat, d.lon]), [optimalLocation.lat, optimalLocation.lon]];
            map.fitBounds(allPoints, { padding: [20, 20] });
        }

        // Display results
        function displayResults() {
            const resultsContent = document.getElementById('resultsContent');
            
            let html = `
                <div class="result-item">
                    <strong>üéØ Optimal Location</strong><br>
                    Coordinates: ${optimalLocation.lat.toFixed(6)}, ${optimalLocation.lon.toFixed(6)}<br>
                    Average Weighted Distance: ${optimalLocation.avgWeightedDistance.toFixed(2)} km
                </div>
            `;

            destinations.forEach((dest, index) => {
                const distance = haversineDistance(optimalLocation.lat, optimalLocation.lon, dest.lat, dest.lon);
                html += `
                    <div class="result-item">
                        <strong>${index + 1}. ${dest.name}</strong><br>
                        Distance from optimal: ${distance.toFixed(2)} km<br>
                        Weight: ${dest.weight}<br>
                        Weighted contribution: ${(distance * dest.weight).toFixed(2)} km¬∑weight
                    </div>
                `;
            });

            html += `
                <div class="result-item">
                    <strong>üìä Analysis Summary</strong><br>
                    Total destinations: ${destinations.length}<br>
                </div>
            `;

            resultsContent.innerHTML = html;
            document.getElementById('results').style.display = 'block';
        }

        // Export results to CSV
        function exportResults() {
            if (!optimalLocation || destinations.length === 0) {
                alert('No results to export');
                return;
            }

const dataToExport = {
    optimalLocation: {
        lat: optimalLocation.lat,
        lon: optimalLocation.lon,
        avgWeightedDistance: optimalLocation.avgWeightedDistance
    },
    destinations: destinations.map(dest => ({
        name: dest.name,
        location: dest.location,
        lat: dest.lat,
        lon: dest.lon,
        weight: dest.weight,
        displayName: dest.display_name // Use display_name for clarity
    }))
};

const json = JSON.stringify(dataToExport, null, 2); // null, 2 for pretty printing


            
            // Download file
            const blob = new Blob([json], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
const timestamp = new Date().toISOString().replace(/[-:T]/g, '').slice(0, 14);
            a.download = `optimal_location_results_${timestamp}.json`;
            
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }



function importResults(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedData = JSON.parse(e.target.result);

            // Basic validation: Check if required top-level keys exist
            if (!importedData.destinations || !Array.isArray(importedData.destinations)) {
                alert("Invalid JSON file: Missing or malformed 'destinations' array.");
                return; // Stop if data is invalid
            }

            // Further validate each destination object
            const validDestinations = importedData.destinations.filter(dest => {
                return typeof dest.name === 'string' &&
                       typeof dest.lat === 'number' && !isNaN(dest.lat) &&
                       typeof dest.lon === 'number' && !isNaN(dest.lon) &&
                       typeof dest.weight === 'number' && !isNaN(dest.weight);
            });

            if (validDestinations.length === 0) {
                alert("No valid destinations found in the imported file. UI will not be updated.");
                return; // Stop if no valid destinations
            }

            // If data is valid, clear current UI and populate
            document.getElementById('destinationsContainer').innerHTML = ''; // Clear existing inputs
            layerGroups.destinations.clearLayers(); // Clear existing markers

            // Add destinations to UI and map
            validDestinations.forEach(dest => {
                const container = document.getElementById('destinationsContainer');
                const destinationItem = document.createElement('div');
                destinationItem.className = 'destination-item';

                const letter = getDestinationLetter(container.children.length);

                // Ensure display_name is populated, fallback to name
                const displayName = dest.displayName || dest.name;

                destinationItem.innerHTML = `
                    <div class="destination-inputs">
                        <div class="autocomplete-container">
                            <input type="text" class="location-input" value="${displayName}" data-lat="${dest.lat}" data-lon="${dest.lon}" data-display-name="${displayName}">
                            <div class="autocomplete-dropdown" style="display: none;"></div>
                        </div>
                        <input type="text" class="name-input" value="${dest.name}">
                        <input type="number" class="weight-input" value="${dest.weight}" min="0.1" step="0.1">
                    </div>
                    <div class="destination-label">Destination: <span class="dest-letter">${letter}</span></div>
                    <button class="btn btn-secondary remove-destination">Remove</button>
                `;

                container.appendChild(destinationItem);

                // Re-attach autocomplete and remove event listeners
                const input = destinationItem.querySelector('.location-input');
                const dropdown = destinationItem.querySelector('.autocomplete-dropdown');
                setupAutocomplete(input, dropdown);

                destinationItem.querySelector('.remove-destination').addEventListener('click', function () {
                    removeDestination(this);
                });

                // Plot on map immediately
                previewDestination(destinationItem, dest.lat, dest.lon, displayName);
            });

            // Re-center map to fit imported destinations if desired (optional)
            if (validDestinations.length > 0) {
                const bounds = L.latLngBounds(validDestinations.map(d => [d.lat, d.lon]));
                map.fitBounds(bounds, { padding: [20, 20] });
            }


        } catch (error) {
            console.error('Error importing JSON file:', error);
            alert("Could not parse the imported file. Please ensure it is a valid JSON format.");
            // No changes made to UI if parsing fails
        }
    };

    reader.readAsText(file);
}



        
        // Initialize the app

window.onload = function() {
    initMap();
    
    // Setup autocomplete for initial destination
    const initialInput = document.querySelector('.location-input');
    const initialDropdown = document.querySelector('.autocomplete-dropdown');
    setupAutocomplete(initialInput, initialDropdown);
    
    // Setup initial remove button
    const initialRemoveButton = document.querySelector('.remove-destination');
    initialRemoveButton.addEventListener('click', function() {
        removeDestination(this);
    });
};
        
    </script>
</body>
</html>
